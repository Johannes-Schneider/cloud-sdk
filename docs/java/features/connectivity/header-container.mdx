---
id: sdk-connectivity-header-container
title: Reading and Manipulating HTTP Headers using the SAP Cloud SDK
hide_title: false
hide_table_of_contents: false
sidebar_label: HTTP Header Container
description: This article describes how to read and manipulate HTTP headers initialy received from the incoming (user) request
keywords:
  - sap
  - cloud
  - sdk
  - headers
  - java
  - connectivity
---

The SAP Cloud SDK for Java offers a broad spectrum of convenience _accessors_.
These _accessors_ can be used to get information such as the currently active _tenant_, the _principal_, and the _authentication token_.
Under the hood, the _accessors_ extract the requested information from the _incoming_ (user) request that is currently being processed.
Before version `3.61.0`, the implementations were relying on Java's `Servlet` API.
Unfortunately, that approach has proven to be inflexible, especially in asynchronous applications.
Therefore, the `RequestHeaderAccessor` was introduced with version `3.61.0` of the SAP Cloud SDK.

## Reading HTTP Headers

The `RequestHeaderAccessor` provides convenient access to the HTTP headers that are contained in the currently processed _incoming_ (user) request:

```java
// throws an exception if there is no incoming request
RequestHeaderContainer headerContainer = RequestHeaderAccessor.getHeaderContainer();

// doesn't throw an exception
Try<RequestHeaderContainer> maybeHeaderContainer = RequestHeaderAccessor.tryGetHeaderContainer();
```

The `RequestHeaderContainer` is an **immutable** collection of HTTP headers.
Each HTTP header consists of a name and arbitrary many values.
To access the values for a specific header, use `RequestHeaderContainer#getHeaderValues(String headerName)`.

:::tip Names are Case-Insensitive

The `RequestHeaderContainer` guarantees that header names are treated case-insensitively when accessing header values.
That way, you can be assured that both calls `myRequestHeaders.getHeaderValues("EXAMPLE")` and `myRequestHeaders.getHeaderValues("example")` will yield the same values.

:::

You can also check whether a certain header is present by using `RequestHeaderAccessor#containsHeader(String headerName)` - also case-insensitive.

### Usage in Other Accessors

As mentioned in the beginning, prior to version `3.61.0`, the SAP Cloud SDK's convenience _accessors_, such as the `AuthTokenAccessor`, used to rely on the incoming `ServletRequest`.
This behavior has been changed in favor of the new `RequestHeaderAccessor`.

## Creating HTTP Header Containers

Creating an instance of the `RequestHeaderContainer` instance can be done in a few ways.

### Static Factories

You may use the static factory methods of the `DefaultRequestHeaderContainer` implementation:
* `DefaultRequestHeaderContainer#fromSingleValueMap(Map<String, String>)`
* `DefaultRequestHeaderContainer#fromMultiValueMap(Map<String, Collection<String>>)`

Both methods assume that each `Map.Entry` of the given parameter represents an individual HTTP header.
The header names are derived from the `Map`'s keys.
Header values are taken from the corresponding value(s).

### Builder

In addition to the static factory methods, there is also the `RequestHeaderContainer.Builder` interface that allows to create new `RequestHeaderContainer` instances.
The SAP Cloud SDK also ships one implementation of that interface: The `DefaultRequestHeaderContainer.Builder` class.

You can use it in the following way:

```java
RequestHeaderContainer headerContainer =
    DefaultRequestHeaderContainer
        .builder()
        .withHeader("single-value-header", "single value")
        .withHeader("multi-value-header", "value 1", "value 2")
        .build();
```

## Manipulating HTTP Header Containers

In some scenarios, it might be needed to update an existing `RequestHeaderContainer` instance.
For example, you might need to attach an additional header to what the _incoming_ request already contained.
Or you could want to delete one of the headers to avoid leaking sensitive information.

Since the `RequestHeaderContainer` interface is designed to be **immutable**, changing the data contained in an existing instance is not possible.
However, we included the `RequestHeaderContainer#toBuilder()` method in the interface.
This method takes care of creating a new `RequestHeaderContainer.Builder` instance, which is already filled with all headers that are contained in the initial container.
That way, you can add, remove, and overwrite existing headers:

```java
RequestHeaderContainer existingHeaderContainer;

RequestHeaderContainer newHeaderContainer =
    existingHeaderContainer
        .toBuilder()
        .withHeader("my-new-header", "value")
        .withoutHeader("header-to-remove")
        .replaceHeader("existing-header", "new value 1", "new value 2")
        .build();
```

You will end up with a **new instance** of the `RequestHeaderContainer` interface that contains the updated header values.

### Forwarding Headers to other Features

Most of the SAP Cloud SDK's functionality that relies on reading HTTP headers has been migrated to use the new `RequestHeaderAccessor` - and therefore also the `RequestHeaderContainer`.
Therefore, explicitly defining which headers should be used by the SAP Cloud SDK is essential in many scenarios.
This can be achieved through the following code:

```java
// `requestHeaders` can be one of the following types:
//  1. An instance of `RequestHeaderContainer`
//  2. A `Map<String, String>`
RequestHeaderAccessor.executeWithHeaderContainer(requestHeaders, myCode);
```

You are free to choose whether you just want to explicitly propagate the headers of the _incoming_ request, an updated variant of them, or something entirely different.

### Asynchronous Tasks

With the new `RequestHeaderAccessor`, executing asynchronous code has become easier and more intuitive.
This is because, in contrast to the `ServletRequest`, the `RequestHeaderContainer` can and will be propagated to "child" threads.

:::danger Caution

For long running asynchronous tasks that "outlive" the root thread, the [workaround](../multi-tenancy/multi-tenancy-thread-context#running-asynchronous-operations) must still be applied.

:::